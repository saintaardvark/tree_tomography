#+TYP_TODO: TODO NEXT | DONE WONTDO
* Journal
** [2023-08-12 Sat]
- https://forums.raspberrypi.com/viewtopic.php?t=306064
  - holy shit, this looks like it could really work -- and in fucking
    micropython, too
  - Good overview: https://forums.raspberrypi.com/viewtopic.php?p=1885119&sid=4cb9c5acddaf88ca3cd9082ab2fbf4b2#p1885119
  - that code: https://github.com/jbeale1/pico/blob/main/QuadHoru1.py
- Spent a bunch of time readying about PIO in pico & understanding
  this code, and *wow* -- this really looks like it can do the trick
** [2023-08-19 Sat]
- Pick up work on Raspberry pi
- Found article on mpu6050.  Turns out there are lots of drivers for
  this, but not as many that include interrupt setting.
  - I could probably figure out how to do this myself, but I'm
    hoping someone has already done the work.
- https://github.com/OneMadGypsy/upy-motion
- Arduino driver w/interrupt: https://github.com/drfailov/MPU6050_Motion-Interrupt/blob/master/MPU6050_MotionInterrupt/MPU6050_MotionInterrupt.ino
- but also: https://github.com/adafruit/Adafruit_MPU6050/blob/master/Adafruit_MPU6050.cpp
  - but also see https://github.com/adafruit/Adafruit_MPU6050/issues/32
    - The code/solution in this issue matches the OneMadGypsy
      interrupt setting
  - Dig a bit more into the OneMadGypsy driver & compare against the
    Adafruit
    - Latching
      - Adafruit's driver sets the latch behaviour by setting 5th
        bit, INT_PIN_CONFIG (0x37).
      - Confirmed in register map (rev 4.2) that this is how it works
      - No latching in OneMadGypsy
    - Motion detection
      - My code for adafruit has:
        #+begin_src cpp
          mpu->setMotionDetectionThreshold(1);
          mpu->setMotionDetectionDuration(1);
          mpu->setInterruptPinLatch(true);	// Keep it latched.  Will turn off when reinitialized.
          mpu->setInterruptPinPolarity(true);
          mpu->setMotionInterrupt(true);
        #+end_src
      - Adafruit drivers has motion detection threshold at register
        0x1f, and motion duration at register 0x20
      - I can't find *either* of those in mpu6050 register map,
        version 4.2
      - RIIIIIGHT: https://www.eluke.nl/2016/08/11/how-to-enable-motion-detection-interrupt-on-mpu6050/
  - Okay, a couple things:
    - I need to consolidate my notes on this.  Prob best to keep in
      tree_tomography.
    - Let's see if I can get the motion threshold & latching working.
      - HAHAHAHHHHA, I did!  ðŸ¥³
        #+begin_src python
          class MyMpu(MPU6050):
              def start(self):
                  """
                  My own version of the Adafruit/eluke.nl code
                  """
                  # mpu->setMotionDetectionThreshold(1);
                  self.__writeByte(0x1F, 0x01)
                  # mpu->setMotionDetectionDuration(1);
                  self.__writeByte(0x20, 0x01)
                  # mpu->setInterruptPinLatch(true);	// Keep it latched.  Will turn off when reinitialized.
                  # Want to set 5th (latch until clear).
                  # Could *also* set 4th bit (clear by reading 0x3a / d58), but will leave that for now.
                  self.__writeByte(0x37, 0x20)
                  # mpu->setInterruptPinPolarity(true);
                  # This is config'd by setting 0x37, 7th bit to 0.  Done above.
                  # mpu->setMotionInterrupt(true);
                  # IntEnable is 0x38.  Need to set 6th bit.
                  self.__writeByte(0x38, 0x40)

        #+end_src
        Need to run:
        #+begin_src python
          >>> mpu.__readByte(0x3a)
          81
        #+end_src
        then can bang the table & it works!

  - Transferred to this repo (had been in pico_scratch)
    - Initial stab at getting interrupts to trigger the pins being
      watched; not sure I have this good yet.
    - GPIO 15 (Pin 20) to mpu6050
    - GIPO 14 (Pin 19) to +3v (thought this was supposed to be ground,
      but no output -- need to re-read my notes)
    - Expecting to be able to boot; run mpu.reset_interrupt(); then
      bang table & stab other pin into +3v.
    - See some output, but a) it's a little obscure, b) not prompted
      by the bang, and c) going very quickly here before moving on to
      other things.
    - *Can* put mpu6050 into pin 4 -- because I still have an
      interrupt handler here -- and bang table & get output
  - Overall:
    - Next up:
      - figure out how the timing code meshes with the interrupt
      - verify whether the mpu6050 working as expected
        - actually, pretty sure it is
      - make output a lot more comprehensible
** [2023-08-23 Wed]
- Picking this up again.
- I'd left undocumented a couple things from last time: the pin
  diagram and the interrupt handling for the MPU.
  - The timing code is watching GPIO 14 & 15 (labels: pin 19 & 20)
  - The mpu6050 is setting up an interrupt handler for GPIO 2 (pin 4)
  - I'd forgotten about the different interrupt pins!  Moving the
    interrupt pin on the MPU to pin 4 does the trick.
- Bit of refactoring:
  - break out my_mpu.py
  - Still a lot to go...this is a very messy main file
- Okay, now I think I'm closer -- and understand what I've got.
  - mpu6050 interrupt pin is wired to GPIO 2.  Interrupt handler there
    will print out to screen when the module is bumped.
    mpu.reset_interrupt() will reset it.
  - mpu6050 int. pin is *also* wired to GPIO 20.  So the timer code
    will see when it goes.
  - GPIO 19 is wired to a switch, with an LED in line as well, which
    goes to +3V.  When the switch is pushed, the LED goes on, and GPIO
    19 sees a rise.
  - I can now do the following sequence:
    - mpu.reset_interrupt()
    - tap the mpu
    - toggle the switch
    - mpu.reset_interrupt() again
  - and after 2 reps (need to understand this a little better), the
    timer interrupt handler will print out timing info
    - ðŸ¥³ðŸ¥³ðŸ¥³
- MyMpu() init is setting the latch for the interrupt.  I think I
  should be able to remove that bit, and I won't need quite so many
  resets.
  - When I do that, flicking the mpu gives *lots* of output.  This is
    not what I want.
  - Reverting to previous behaviour.
* Pinout
- Pico GPIO 2 (label: 4) -> MPU 6050 interrupt pin
- Pico GPIO 14 (label: 19) -> MPU 6050 interrupt pin
- Pico GPIO 15 (label: 20) -> LED -> switch -> resistor -> +3V
- Pico I2C 0 SDA (label: 26) -> MPU 6050 SDA
- Pico I2C 0 SCL (label: 27) -> MPU 6050 SCL

* Notes & references
** What times do I expect?
For my test setup (~47 cm): something like 470-570 ms
- Assume pine -- softwood
- 47 cm * 10 == 470ms
- 47 cm * 12 == 564
https://www.youtube.com/watch?v=dAhwgIk0HU4
- Speed of sound ("stress wave transit times")
  - Hardwood: 7-9 microseconds/cm
  - Softwood: 10-12 microseconds/cm
- So nominal 30cm trunk diameter: 210-360 microseconds
- which means needing something like 5 Mhz
- Also: see docs fole

** Setting another pin for I2C
- ESP32 can set any pin for i2c, as long as it's not in use by another function
- https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/
  #+begin_src c++
    // These are open in the WeMos Lolin32Lite

    #include <Wire.h>

    #define I2C_SDA 23
    #define I2C_SCL 19

    Wire.begin(I2C_SDA, I2C_SCL);
  #+end_src
  - https://esp32.com/viewtopic.php?t=6402
* TODOs
** DONE Print out welcome screen at bootup
CLOSED: [2023-08-05 Sat 06:00]
** DONE Print "Armed..." screen
CLOSED: [2023-08-05 Sat 06:02]
** DONE Print out elapsed time to screen & don't overwrite it until armed again
CLOSED: [2023-08-05 Sat 06:02]
** DONE Detect hammer hit
CLOSED: [2023-08-05 Sat 14:18]
- Pick pin for digital (?) interrupt
- Test with button push
- Break out to more foil, alligator clip
- Test w/hammer hit

** DONE Interrupt for mpu6050?
CLOSED: [2023-08-10 Thu 17:20]
- https://www.eluke.nl/2016/08/11/how-to-enable-motion-detection-interrupt-on-mpu6050/
- https://arduino.stackexchange.com/questions/48424/how-to-generate-hardware-interrupt-in-mpu6050-to-wakeup-arduino-from-sleep-mode
- maybe https://github.com/jrowberg/i2cdevlib/blob/master/Arduino/MPU6050/examples/MPU6050_DMP6/MPU6050_DMP6.ino
- https://www.fpaynter.com//2019/10/basic-arduino-mpu6050-gy-521-test/
  - which refers to the jrowberg/ic2devlib library, though more about
    polling
** ESP32 TODOs
*** TODO Fix hammer timing
- https://www.esp32.com/viewtopic.php?t=15734
- https://forum.arduino.cc/t/measuring-pulse-duration-more-accurately-with-esp32/997745/7
  - https://sub.nanona.fi/esp8266/timing-and-ticks.html
- https://esp32.com/viewtopic.php?t=4113
*** TODO Break out threshold calculation to its own function
*** TODO Consistify snake_case / camelCase varnames
*** TODO Interrupt reset for mpu6050
- Currently I have to power cycle the esp32 to get another interrupt
  to work. I'm assuming there's a reset I can do on the mpu itself --
  probably something that's currently in the init routine for the mpu.
** DONE Try using ESP IDF + Arduino IDE
CLOSED: [2023-08-19 Sat 16:21]
Follow up to step 3 at https://espressif-docs.readthedocs-hosted.com/projects/arduino-esp32/en/latest/esp-idf_component.html
#+begin_quote
mkdir -p components && \
cd components && \
git clone https://github.com/espressif/arduino-esp32.git arduino && \
cd arduino && \
git submodule update --init --recursive && \
cd ../.. && \
idf.py menuconfig
#+end_quote
- menuconfig part fails
  #+begin_quote
  CMake Error at
  /home/aardvark/dev/src/esp/sample_project/components/arduino/CMakeLists.txt:19
  (message):

  Arduino-esp32 can be used with ESP-IDF versions between 4.4.0 and 4.4.99,
  but a newer version is detected: 5.1.0.
  #+end_quote
- https://github.com/espressif/arduino-esp32/issues/7852
- Try reverting to 4.4.5
- that worked
- Had to edit sdkconfig & set CONFIG_FREERTOS_HZ=1000
- Okay, found menuconfig for timer:
  - component config
    - High resolution timer (esp_timer)
- Try compiling OllieK demo
  - cp timer* main
  - rename timer_u32_main.c to main.c
  - idf.py build
    #+begin_quote
    timer.a(esp_timer.c.obj):(.literal.esp_timer_early_init+0x0): undefined reference to `esp_timer_impl_early_init'
    /home/aardvark/.espressif/tools/xtensa-esp32-elf/esp-2021r2-patch5-8.4.0/xtensa-esp32-elf/bin/../lib/gcc/xtensa-esp32-elf/8.4.0/../../../../xtensa-esp32-elf/bin/ld: esp-idf/esp_timer/libesp_timer.a(esp_timer.c.obj): in function `esp_timer_early_init':
    /home/aardvark/dev/src/esp/esp-idf/components/esp_timer/src/esp_timer.c:425: undefined reference to `esp_timer_impl_early_init'

    #+end_quote
- At this point I set things aside for a week.
- Have not come back to it yet; found the Pico micropython approach &
  it looks quite promising.
** WONTDO Use this code on pico - micropython
CLOSED: [2023-08-23 Wed 07:14]
- https://codeandlife.com/2012/07/03/benchmarking-raspberry-pi-gpio-speed/
  - 22MHz w/Pi -- so ~ 45 ns/pulse
  - though this is for *sending* signals w/gpio on pi
