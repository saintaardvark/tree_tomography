#+TYP_TODO: TODO NEXT | DONE WONTDO
* Journal
** [2023-08-12 Sat]
- https://forums.raspberrypi.com/viewtopic.php?t=306064
  - holy shit, this looks like it could really work -- and in fucking
    micropython, too
  - Good overview: https://forums.raspberrypi.com/viewtopic.php?p=1885119&sid=4cb9c5acddaf88ca3cd9082ab2fbf4b2#p1885119
  - that code: https://github.com/jbeale1/pico/blob/main/QuadHoru1.py
- Spent a bunch of time readying about PIO in pico & understanding
  this code, and *wow* -- this really looks like it can do the trick
** [2023-08-19 Sat]
- Pick up work on Raspberry pi
- Found article on mpu6050.  Turns out there are lots of drivers for
  this, but not as many that include interrupt setting.
  - I could probably figure out how to do this myself, but I'm
    hoping someone has already done the work.
- https://github.com/OneMadGypsy/upy-motion
- Arduino driver w/interrupt: https://github.com/drfailov/MPU6050_Motion-Interrupt/blob/master/MPU6050_MotionInterrupt/MPU6050_MotionInterrupt.ino
- but also: https://github.com/adafruit/Adafruit_MPU6050/blob/master/Adafruit_MPU6050.cpp
  - but also see https://github.com/adafruit/Adafruit_MPU6050/issues/32
    - The code/solution in this issue matches the OneMadGypsy
      interrupt setting
  - Dig a bit more into the OneMadGypsy driver & compare against the
    Adafruit
    - Latching
      - Adafruit's driver sets the latch behaviour by setting 5th
        bit, INT_PIN_CONFIG (0x37).
      - Confirmed in register map (rev 4.2) that this is how it works
      - No latching in OneMadGypsy
    - Motion detection
      - My code for adafruit has:
        #+begin_src cpp
          mpu->setMotionDetectionThreshold(1);
          mpu->setMotionDetectionDuration(1);
          mpu->setInterruptPinLatch(true);	// Keep it latched.  Will turn off when reinitialized.
          mpu->setInterruptPinPolarity(true);
          mpu->setMotionInterrupt(true);
        #+end_src
      - Adafruit drivers has motion detection threshold at register
        0x1f, and motion duration at register 0x20
      - I can't find *either* of those in mpu6050 register map,
        version 4.2
      - RIIIIIGHT: https://www.eluke.nl/2016/08/11/how-to-enable-motion-detection-interrupt-on-mpu6050/
  - Okay, a couple things:
    - I need to consolidate my notes on this.  Prob best to keep in
      tree_tomography.
    - Let's see if I can get the motion threshold & latching working.
      - HAHAHAHHHHA, I did!  ðŸ¥³
        #+begin_src python
          class MyMpu(MPU6050):
              def start(self):
                  """
                  My own version of the Adafruit/eluke.nl code
                  """
                  # mpu->setMotionDetectionThreshold(1);
                  self.__writeByte(0x1F, 0x01)
                  # mpu->setMotionDetectionDuration(1);
                  self.__writeByte(0x20, 0x01)
                  # mpu->setInterruptPinLatch(true);	// Keep it latched.  Will turn off when reinitialized.
                  # Want to set 5th (latch until clear).
                  # Could *also* set 4th bit (clear by reading 0x3a / d58), but will leave that for now.
                  self.__writeByte(0x37, 0x20)
                  # mpu->setInterruptPinPolarity(true);
                  # This is config'd by setting 0x37, 7th bit to 0.  Done above.
                  # mpu->setMotionInterrupt(true);
                  # IntEnable is 0x38.  Need to set 6th bit.
                  self.__writeByte(0x38, 0x40)

        #+end_src
        Need to run:
        #+begin_src python
          >>> mpu.__readByte(0x3a)
          81
        #+end_src
        then can bang the table & it works!

  - Transferred to this repo (had been in pico_scratch)
    - Initial stab at getting interrupts to trigger the pins being
      watched; not sure I have this good yet.
    - GPIO 15 (Pin 20) to mpu6050
    - GIPO 14 (Pin 19) to +3v (thought this was supposed to be ground,
      but no output -- need to re-read my notes)
    - Expecting to be able to boot; run mpu.reset_interrupt(); then
      bang table & stab other pin into +3v.
    - See some output, but a) it's a little obscure, b) not prompted
      by the bang, and c) going very quickly here before moving on to
      other things.
    - *Can* put mpu6050 into pin 4 -- because I still have an
      interrupt handler here -- and bang table & get output
  - Overall:
    - Next up:
      - figure out how the timing code meshes with the interrupt
      - verify whether the mpu6050 working as expected
        - actually, pretty sure it is
      - make output a lot more comprehensible
** [2023-08-23 Wed]
- Picking this up again.
- I'd left undocumented a couple things from last time: the pin
  diagram and the interrupt handling for the MPU.
  - The timing code is watching GPIO 14 & 15 (labels: pin 19 & 20)
  - The mpu6050 is setting up an interrupt handler for GPIO 2 (pin 4)
  - I'd forgotten about the different interrupt pins!  Moving the
    interrupt pin on the MPU to pin 4 does the trick.
- Bit of refactoring:
  - break out my_mpu.py
  - Still a lot to go...this is a very messy main file
- Okay, now I think I'm closer -- and understand what I've got.
  - mpu6050 interrupt pin is wired to GPIO 2.  Interrupt handler there
    will print out to screen when the module is bumped.
    mpu.reset_interrupt() will reset it.
  - mpu6050 int. pin is *also* wired to GPIO 20.  So the timer code
    will see when it goes.
  - GPIO 19 is wired to a switch, with an LED in line as well, which
    goes to +3V.  When the switch is pushed, the LED goes on, and GPIO
    19 sees a rise.
  - I can now do the following sequence:
    - mpu.reset_interrupt()
    - tap the mpu
    - toggle the switch
    - mpu.reset_interrupt() again
  - and after 2 reps (need to understand this a little better), the
    timer interrupt handler will print out timing info
    - ðŸ¥³ðŸ¥³ðŸ¥³
- MyMpu() init is setting the latch for the interrupt.  I think I
  should be able to remove that bit, and I won't need quite so many
  resets.
  - When I do that, flicking the mpu gives *lots* of output.  This is
    not what I want.
  - Reverting to previous behaviour.
- Updated pinout in README as well as adding it below.
** [2023-08-24 Thu]
- Some refactoring to make the code clearer, plus some notes added to
  the code.
- Figured out I was doing the switch wrong; fixed.  Now I can hit it
  and have it trigger Pin 15.  Adjusted pin notes to match.
** [2023-08-26 Sat]
- Trying out piezo sensor
  - Out of the box, the threshold for the digital timer seems good.
  - Hooked up to the far size of the switch
    - digital out -> pos LED -> neg LED -> GPIO 15 (label 20)
    - Hm: had to hook up gpio15 to *pos* LED -- got this wrong.
  - *WOW*, the wiring on this is delicate.  Broke one already.  Tried
    to re-solder it, but no luck.
- This mostly worked today...for a while.
  - Ihad piezo on one side of board, mpu on other. 55cm distance
    between them -- so anywhere from 550 to 660 microseconds.
    - I was getting quite consistent times of ~ 1000-1300 microseconds
      -- about double, but not orders of magnitude off.  As well,
      there's the time of flight times in the paper; I don't remember
      the details, but they were *way* higher when crossing the
      grain...as this is, plus it's all separate pieces of board glued
      together.
  - Set up a second piezeo on other side -- say, 25cm apart.
    - Here, banging on opposite side (so they were both about the same
      distance away from the hammer -- about 50cm, say), the time
      between the two was much shorter -- 5 microseconds, say.
    - But when I hit next to the piezo, the time between them was
      *still* about 5 microseconds.
    - And it *stayed* like that when I switched back to the other
      sensor.
  - Not sure what happened here.
    - The way I'm counting time needs to be recorded: I have, for
      today, assumed that the line that has both ON records the time
      from the *last* state change (one of them turning on) to *this*
      state (both on).
    - Not sure that's correct!  Need to re-read my notes & the code.
    - Still -- progress!
** [2023-09-09 Sat]
- Coming back to this after two weeks off.
- Current state:
  - Two piezos.
    - "Left" one (closer to hammer hit) goes to GPIO 15.
    - "Right" one (further from hammer hit) goes to GPIO 14.
    - LEDs attached to both piezo interrupt pins.  I can see them
      trigger when I give the board a hit.
      - I can also tap them both w/fingers & see the flash.
- Still not understanding the times I'm seeing.  Typical with hammer
  hit on left pin:
  #+begin_quote
  Piezo: ON    MPU: OFF   Time: 41.85 microseconds
  Piezo: ON    MPU: ON    Time: 870.649 microseconds ðŸ‘ˆ
  Piezo: ON    MPU: OFF   Time: 261.266 microseconds
  Piezo: OFF   MPU: OFF   Time: 4.038 microseconds
  #+end_quote
  Or:
  #+begin_quote
  Piezo: ON    MPU: OFF   Time: 13.241 microseconds
  Piezo: ON    MPU: OFF   Time: 4.357 microseconds
  Piezo: ON    MPU: ON    Time: 14.777 microseconds ðŸ‘ˆ
  Piezo: ON    MPU: OFF   Time: 151.774 microseconds
  #+end_quote
  Or:
  #+begin_quote
  Piezo: ON    MPU: OFF   Time: 5.106 microseconds
  Piezo: ON    MPU: OFF   Time: 3.436 microseconds
  Piezo: ON    MPU: ON    Time: 3.182 microseconds ðŸ‘ˆ
  Piezo: ON    MPU: OFF   Time: 102.246 microseconds
  #+end_quote
- Looking over counter.py again, that SM only watches one pin -- pin
  16, which both trigger SMs set as the result of seeing a change in
  state.
  - The assumption is that first one pin, *then the other*, will be
    triggered -- that the *first* change in pin 16 is from the left
    pin, and the *second* is from the right pin.
  - But that's not necessarily true!  The signals from the piezos are
    *not* latched up, so we could be seeing up/down from the left pin
    before the right pin triggers.
    - This could be adjusted by having the triggers sleep after
      receiving the initial signal.
- Also, though, I'm not sure I fully understand the time that's being
  recorded.
  - Going over counter.py, the clock starts when pin 16 (again, set by
    either of the triggers on state change) to go high.
  - When pin 16 goes low, dump state of pin 14/15 into ISR.
  - Wait for pin 16 to go high again.  At this point, <handwave> dump
    number of clock cycles into ISR </handwave>.
  - Set IRQ & block 'til done
- So:
  - Ideally, each line is *how long was spent in that state*
    - dump pin state at start
    - once there's a change, dump the time
    - GOTO start
  - *If* the dump state is done while the first high is still going,
    you'll have 1,0, [time until next event]
- Re-reading [[https://forums.raspberrypi.com/viewtopic.php?t=306064&sid=05eb8eb20a34f7d5a7eac4cec91a7999][the original thread]]
  - There's a post with a *much* simpler approach: a single state
    machine that watches two pins, and counts the time between each
    going high.  That's a lot closer to what I'm after.
  - I suspect this will be a good approach to try.
    - Hm, you could even imagine setting up one SM to watch hammer
      pin & set *another* pin when that happens -- which in turn would
      be the sign for the other 3 SMs to start watching *their* pins
      and collect *their* time-of-flight details.
* TODOs
** DONE Print out welcome screen at bootup
CLOSED: [2023-08-05 Sat 06:00]
** DONE Print "Armed..." screen
CLOSED: [2023-08-05 Sat 06:02]
** DONE Print out elapsed time to screen & don't overwrite it until armed again
CLOSED: [2023-08-05 Sat 06:02]
** DONE Detect hammer hit
CLOSED: [2023-08-05 Sat 14:18]
- Pick pin for digital (?) interrupt
- Test with button push
- Break out to more foil, alligator clip
- Test w/hammer hit

** DONE Interrupt for mpu6050?
CLOSED: [2023-08-10 Thu 17:20]
- https://www.eluke.nl/2016/08/11/how-to-enable-motion-detection-interrupt-on-mpu6050/
- https://arduino.stackexchange.com/questions/48424/how-to-generate-hardware-interrupt-in-mpu6050-to-wakeup-arduino-from-sleep-mode
- maybe https://github.com/jrowberg/i2cdevlib/blob/master/Arduino/MPU6050/examples/MPU6050_DMP6/MPU6050_DMP6.ino
- https://www.fpaynter.com//2019/10/basic-arduino-mpu6050-gy-521-test/
  - which refers to the jrowberg/ic2devlib library, though more about
    polling
** WONTDO ESP32 TODOs
CLOSED: [2023-08-24 Thu 07:17]
*** TODO Fix hammer timing
- https://www.esp32.com/viewtopic.php?t=15734
- https://forum.arduino.cc/t/measuring-pulse-duration-more-accurately-with-esp32/997745/7
  - https://sub.nanona.fi/esp8266/timing-and-ticks.html
- https://esp32.com/viewtopic.php?t=4113
*** TODO Break out threshold calculation to its own function
*** TODO Consistify snake_case / camelCase varnames
*** TODO Interrupt reset for mpu6050
- Currently I have to power cycle the esp32 to get another interrupt
  to work. I'm assuming there's a reset I can do on the mpu itself --
  probably something that's currently in the init routine for the mpu.
** DONE Try using ESP IDF + Arduino IDE
CLOSED: [2023-08-19 Sat 16:21]
Follow up to step 3 at https://espressif-docs.readthedocs-hosted.com/projects/arduino-esp32/en/latest/esp-idf_component.html
#+begin_quote
mkdir -p components && \
cd components && \
git clone https://github.com/espressif/arduino-esp32.git arduino && \
cd arduino && \
git submodule update --init --recursive && \
cd ../.. && \
idf.py menuconfig
#+end_quote
- menuconfig part fails
  #+begin_quote
  CMake Error at
  /home/aardvark/dev/src/esp/sample_project/components/arduino/CMakeLists.txt:19
  (message):

  Arduino-esp32 can be used with ESP-IDF versions between 4.4.0 and 4.4.99,
  but a newer version is detected: 5.1.0.
  #+end_quote
- https://github.com/espressif/arduino-esp32/issues/7852
- Try reverting to 4.4.5
- that worked
- Had to edit sdkconfig & set CONFIG_FREERTOS_HZ=1000
- Okay, found menuconfig for timer:
  - component config
    - High resolution timer (esp_timer)
- Try compiling OllieK demo
  - cp timer* main
  - rename timer_u32_main.c to main.c
  - idf.py build
    #+begin_quote
    timer.a(esp_timer.c.obj):(.literal.esp_timer_early_init+0x0): undefined reference to `esp_timer_impl_early_init'
    /home/aardvark/.espressif/tools/xtensa-esp32-elf/esp-2021r2-patch5-8.4.0/xtensa-esp32-elf/bin/../lib/gcc/xtensa-esp32-elf/8.4.0/../../../../xtensa-esp32-elf/bin/ld: esp-idf/esp_timer/libesp_timer.a(esp_timer.c.obj): in function `esp_timer_early_init':
    /home/aardvark/dev/src/esp/esp-idf/components/esp_timer/src/esp_timer.c:425: undefined reference to `esp_timer_impl_early_init'

    #+end_quote
- At this point I set things aside for a week.
- Have not come back to it yet; found the Pico micropython approach &
  it looks quite promising.
** WONTDO Use this code on pico - micropython
CLOSED: [2023-08-23 Wed 07:14]
- https://codeandlife.com/2012/07/03/benchmarking-raspberry-pi-gpio-speed/
  - 22MHz w/Pi -- so ~ 45 ns/pulse
  - though this is for *sending* signals w/gpio on pi

** DONE Better output -- clearer, easier to understand
CLOSED: [2023-08-26 Sat 14:21]
- Here I'm thinking of the interrupt handler.
- I can imagine two approaches:
  - Put a nice print in the interrupt handler.  Normally that's bad,
    but for this I don't anticipate doing much after the first set of
    interrupts are handled; no worries about stuffing more in here.
  - Just have the interrupt handler write values to a global array or
    some such, and have another routine watching it & printing things
    as they come in.
** DONE Try out piezo sensor
CLOSED: [2023-08-26 Sat 14:21]

** TODO How to get the timer working w/o so many resets?
** TODO Go through thread to make sure I've captured everything
** TODO Would an ECG cable work for this?
- https://voltagedivide.com/2017/10/14/psoc-design-and-implementation-of-a-12-lead-portable-ecg/
* Pinout
- "switch in" meaning closer to the Pico
- Pico GPIO 2 (label: 4) -> MPU 6050 interrupt pin
- Pico GPIO 14 (label: 19) -> MPU 6050 interrupt pin - 0b01
- Pico GPIO 15 (label: 20) -> piezo digital -> switch out -> resistor -> +3V  - 0b10
                              |
                              +-> neg LED lead -> GND
- Pico I2C 0 SDA (label: 26) -> MPU 6050 SDA
- Pico I2C 0 SCL (label: 27) -> MPU 6050 SCL

* Notes & references
** What times do I expect?
For my test setup (~55 cm): something like 470-570 microseconds
- Assume pine -- softwood
- 55 cm * 10 == 550 microseconds
- 55 cm * 12 == 660 microseconds
https://www.youtube.com/watch?v=dAhwgIk0HU4
- Speed of sound ("stress wave transit times")
  - Hardwood: 7-9 microseconds/cm
  - Softwood: 10-12 microseconds/cm
- So nominal 30cm trunk diameter: 210-360 microseconds
- which means needing something like 5 Mhz
- Also: see docs fole

** Setting another pin for I2C
- ESP32 can set any pin for i2c, as long as it's not in use by another function
- https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/
  #+begin_src c++
    // These are open in the WeMos Lolin32Lite

    #include <Wire.h>

    #define I2C_SDA 23
    #define I2C_SCL 19

    Wire.begin(I2C_SDA, I2C_SCL);
  #+end_src
  - https://esp32.com/viewtopic.php?t=6402
